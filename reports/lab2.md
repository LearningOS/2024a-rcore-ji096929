我实现了以下功能：
在 TaskControlBlock 中添加了系统调用计数器 syscall_times 和任务开始时间 start_time 字段，用于记录任务的运行信息。
在 TaskManager 中实现了 get_current_task_info 方法，用于获取当前运行任务的状态信息，包括任务状态、系统调用次数统计和运行时间。
添加了 increment_syscall 方法来增加指定系统调用的计数。
修改了 run_first_task 方法，在任务开始运行时记录其开始时间。
实现了 sys_task_info 系统调用，通过调用 TaskManager 的方法获取当前任务信息并返回给用户空间。
这些实现使得操作系统能够追踪和统计每个任务的运行状态、系统调用使用情况和运行时间，为用户程序提供了任务信息查询的功能。

SV39页表项组成：
PPN[2]: 物理页号高位
PPN[1]: 物理页号中位
PPN[0]: 物理页号低位
RSW: 预留给S模式软件使用
D: Dirty位,表示页面是否被写入
A: Accessed位,表示页面是否被访问
G: Global位,表示页面是否在所有地址空间共享
U: User位,控制用户态是否可访问
X: 可执行
W: 可写入
R: 可读取
V: 有效位
缺页可能导致的异常：
Store/Load Page Fault
Store/Load Fault
缺页时重要寄存器：
scause: 记录异常原因(Page Fault)
stval: 记录导致异常的虚拟地址
sepc: 记录发生异常的指令地址
Lazy策略的好处：
减少内存占用：只在实际需要时分配物理内存
加快进程启动：不需要一次性加载所有内容
提高内存利用率：避免分配未使用的内存
10G连续内存的SV39页表占用估算：
每页4KB,10G需要约2.5M个页表项
三级页表,每级页表项8字节
一级页表:1个
二级页表:~512个
三级页表:~2.5K个
总计约(1 + 512 + 2500) 4KB ≈ 12MB
Lazy策略实现思路：
mmap时只建立虚拟地址区间记录,不实际分配物理页和建立映射
访问未映射地址时触发Page Fault
在Page Fault处理程序中检查是否是Lazy分配的区间
是则分配物理页并建立映射,然后返回重试
不是则报错终止进程
7. Swap导致的页面失效在PTE上的表现：
V(Valid)位为0
PPN字段可用于存储该页面在磁盘上的位置信息
单页表切换：
通过修改satp寄存器切换根页表
需要刷新TLB
单页表控制用户访问：
通过页表项的U位控制
U=0表示仅内核态可访问
单页表优势：
TLB利用率更高
内存开销更小
切换开销更小
11. 页表切换时机：
双页表：进入/退出内核态时需要切换
单页表：仅进程切换时需要切换



荣誉准则
在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
无

此外，我也参考了以下资料，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
无

我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

看法
无
