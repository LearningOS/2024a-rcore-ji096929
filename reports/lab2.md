我实现了以下功能：
在 TaskControlBlock 中添加了系统调用计数器 syscall_times 和任务开始时间 start_time 字段，用于记录任务的运行信息。
在 TaskManager 中实现了 get_current_task_info 方法，用于获取当前运行任务的状态信息，包括任务状态、系统调用次数统计和运行时间。
添加了 increment_syscall 方法来增加指定系统调用的计数。
修改了 run_first_task 方法，在任务开始运行时记录其开始时间。
实现了 sys_task_info 系统调用，通过调用 TaskManager 的方法获取当前任务信息并返回给用户空间。
这些实现使得操作系统能够追踪和统计每个任务的运行状态、系统调用使用情况和运行时间，为用户程序提供了任务信息查询的功能。


SV39页表项组成：
PPN[2]: 物理页号高位
PPN[1]: 物理页号中位
PPN[0]: 物理页号低位
RSW: 预留给S模式软件使用
D: Dirty位,表示页面是否被写入
A: Accessed位,表示页面是否被访问
G: Global位,表示页面是否在所有地址空间共享
U: User位,控制用户态是否可访问
X: 可执行
W: 可写入
R: 可读取
V: 有效位
缺页可能导致的异常：
Store/Load Page Fault
Store/Load Fault
缺页时重要寄存器：
scause: 记录异常原因(Page Fault)
stval: 记录导致异常的虚拟地址
sepc: 记录发生异常的指令地址
Lazy策略的好处：
减少内存占用：只在实际需要时分配物理内存
加快进程启动：不需要一次性加载所有内容
提高内存利用率：避免分配未使用的内存
10G连续内存的SV39页表占用估算：
每页4KB,10G需要约2.5M个页表项
三级页表,每级页表项8字节
一级页表:1个
二级页表:~512个
三级页表:~2.5K个
总计约(1 + 512 + 2500) 4KB ≈ 12MB
Lazy策略实现思路：
mmap时只建立虚拟地址区间记录,不实际分配物理页和建立映射
访问未映射地址时触发Page Fault
在Page Fault处理程序中检查是否是Lazy分配的区间
是则分配物理页并建立映射,然后返回重试
不是则报错终止进程
7. Swap导致的页面失效在PTE上的表现：
V(Valid)位为0
PPN字段可用于存储该页面在磁盘上的位置信息
单页表切换：
通过修改satp寄存器切换根页表
需要刷新TLB
单页表控制用户访问：
通过页表项的U位控制
U=0表示仅内核态可访问
单页表优势：
TLB利用率更高
内存开销更小
切换开销更小
11. 页表切换时机：
双页表：进入/退出内核态时需要切换
单页表：仅进程切换时需要切换
